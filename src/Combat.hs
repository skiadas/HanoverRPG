{-|
Module      : Combat
Description : The Combat module
Copyright   : (c) Kenny Jarnagin, 2017
                  Lucas Miller, 2017
License     : MIT
Maintainer  : jarnagink19@hanover.edu

This module is designed to carryout the "battle phase" of the Battle for the Point game.

Basically, this module is given a "hero" and an "enemy" unit and then communicates with the UI and AI teams
to figure out what their units do, respectively. The battle ends when one of the units is "dead".


-}

module Combat
(
    doBattle
) where

import Combat.ActionOptions
import Unit
import UI 
import AI 


--Determine what the actual effect generated by the source unit is 
--Takes a Unit and an action and calculates the amount of damage (or healing) dealt by the source
actionValue :: Unit -> Action -> Int
actionValue source (Attack (source, target)) = -((attack*speed)/10) + defense
    where attack  = getAttack source
          speed   = getSpeed source
          defense = (getDefense target) % 2
actionValue source (Heal (source, _))   = 10


--Given a Source Unit, a Target Unit and some action (defined in Action.hs), update the Target's health
updateUnit :: Unit -> Unit -> Action -> Unit 
updateUnit source target action = health + effect
    where effect = actionValue source action
          health = getHealth target

{-  
    1) Carry out the action provided by the UI team. Continue the "battle" until either the source or target
        (also referred to as "hero" and "enemy" in other modules) is dead.
    2) To begin, we must ask UI for an action to be taken (should be of IO type). 
    3) Then, we need to see if the current source is dead or not. 
         If the source (in this case, the hero unit) is dead, we need to return (source,target) because
         other teams are dependent on the (hero,enemy) tuple. 
    4) When the action phase is complete, we need to ask the enemy for their action in order to continue the battle 
         (Call the enemyTurn function)
-}

heroTurn :: Unit -> Unit -> IO (Unit, Unit)
heroTurn source target = do
    turn <- UI.getAction((source, target))
    if isDead(source) = return (source, target)
    else 
        case turn of
            Attack (source, target) -> updateUnit source target turn
            Heal   (source, target) -> updateUnit source target turn
    enemyTurn target source

{-  
    1)  Carry out the action provided by the UI team. Continue the "battle" until either the source or target
        (also referred to as "hero" and "enemy" in other modules) is dead.
    2) To begin, we must ask AI for an action to be taken (should be of IO type). 
    3) Then, we need to see if the current source is dead or not. 
         If the source (in this case, the enemy unit) is dead, we need to return (target,source) because
         other teams are dependent on the (hero,enemy) tuple. However, this function is written as (enemy, hero).
    4) When the action phase is complete, we need to ask the hero for their action in order to continue the battle 
         (Call the heroTurn function)
-}
enemyTurn :: Unit -> Unit -> IO (Unit, Unit)
enemyTurn source target = do
    turn <- AI.chooseAction((source,target))
    if isDead(source) = return (target,source)
    else 
        case turn of
            Attack (source, target)-> updateUnit source target turn
            Heal   (source, target)-> updateUnit source target turn
    heroTurn target source 

{- 
   This is the primary function that is used to call the rest of the combat functions.
   This takes two units and returns an IO unit for the game module to store and update in state.
   Determines which character goes first based off of who has the highest speed and begins combat.
-}
doBattle :: Unit -> Unit -> IO (Unit, Unit)
doBattle hero enemy | getSpeed(hero) >= getSpeed(enemy) = heroTurn hero enemy
                    | otherwise = enemyTurn enemy hero






