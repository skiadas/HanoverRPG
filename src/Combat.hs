{-|
Module      : Combat
Description : The Combat module
Copyright   : (c) Kenny Jarnagin, 2017
                  Lucas Miller, 2017
License     : MIT
Maintainer  : jarnagink19@hanover.edu

Here is a longer description of this module, containing some
commentary with @some markup@. 
-}

module Combat
(
    updateUnit
) where

import Combat.ActionOptions
import Unit
import UI 
import AI 


--Determine what the actual effect generated by the source unit is 
--Takes a Unit and an action and calculates the amount of damage (or healing) dealt by the source
actionValue :: Unit -> Action -> Int
actionValue source (Attack (source, target)) = -((attack*speed)/10) + defense
    where attack  = getAttack source
          speed   = getSpeed source
          defense = (getDefense target) % 2
actionValue source (Heal (source, _))   = 10


--Given a Source Unit, a Target Unit and some action (defined in Action.hs), update the Target's health
updateUnit :: Unit -> Unit -> Action -> Unit 
updateUnit source target action = health + effect
    where effect = actionValue source action
          health = getHealth target

--Carry out the action provided by the UI team. sourceTurn & targetTurn should be calling each other
--to continue the fight until the UI or the AI unit "isDead"
heroTurn :: Unit -> Unit -> IO (Unit, Unit)
heroTurn source target = do
    turn <- UI.getAction((source, target))
    if getHealth(source) <= 0 = return (source, target)
    else 
        case turn of
            Attack (source, target) -> updateUnit source target turn
            Heal   (source, target) -> updateUnit source target turn
    --Action phase is complete, now we ask the "enemy" for their action choice through the enemyTurn function
    enemyTurn target source

--Carry out the action provided by the AI team. sourceTurn & targetTurn should be calling each other
--to continue the fight until the UI or the AI unit "isDead"
enemyTurn :: Unit -> Unit -> IO (Unit, Unit)
enemyTurn source target = do
    --Request the action from the AI module (should be of IO type)
    turn <- AI.chooseAction((source,target))
    --Checks to see if current source is dead. If they are, we only need to return the pairing
    --Must return (target,source) to be consistent with the accepted values of (hero, enemy)
    if getHealth(source) <= 0 = return (target,source)
    else
        case turn of
            Attack (source, target)-> updateUnit source target turn
            Heal   (source, target)-> updateUnit source target turn
    --Action phase has been completed, now we ask the "hero" for their action choice
    --by calling the heroTurn function
    heroTurn target source 

--This is the primary function that is used to call the rest of the combat functions
--This takes two units and returns an IO unit for the game module to store and update
--Determines which character goes first based off of who has the highest speed
doBattle :: Unit -> Unit -> IO (Unit, Unit)
doBattle source target | getSpeed(source) >= getSpeed(target) = heroTurn source target
                       | otherwise = enemyTurn target source






